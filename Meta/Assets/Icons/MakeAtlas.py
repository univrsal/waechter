#!/usr/bin/env python3
"""
MakeAtlas.py

Packs square PNG icons into a power-of-two atlas and generates a C++ header
mapping icon name -> (x, y) top-left coordinates.

Updated:
 - Ignores any input file named like the output atlas (e.g. atlas.png) to prevent self-inclusion.
 - Accepts arbitrary size/aspect PNGs. Determines a target icon size automatically (minimum of min(width,height) across inputs) and downsizes larger images while preserving aspect ratio. Images are letterboxed (centered) on a square transparent canvas of icon_size x icon_size without upscaling smaller ones.
 - Adds a 1-pixel padding around each icon cell (gap on all four sides) to prevent texture bleeding when sampling the atlas.

Usage:
    python MakeAtlas.py [--in ./icons] [--out-atlas atlas.png] [--out-header icon_atlas_map.h]
"""

import argparse
import os
import sys
from pathlib import Path
from typing import List, Tuple

try:
    import PIL.Image as PILImage
except ImportError:
    print("Error: Pillow (PIL) library not found. Install with: pip install Pillow", file=sys.stderr)
    PILImage = None
    sys.exit(1)

assert PILImage is not None, "Pillow must be installed"

POWER2_MIN = 64  # minimal atlas side to consider
POWER2_MAX = 16384  # safety cap
PAD = 1  # pixels of transparent padding around each icon to avoid bleeding


def find_min_power2_side(n_images, cell_stride, pow2_min=POWER2_MIN, pow2_max=POWER2_MAX):
    """Find smallest square power-of-two side such that
    floor(side/cell_stride) * floor(side/cell_stride) >= n_images
    cell_stride is the per-icon cell size including padding.
    """
    k = (cell_stride - 1).bit_length()
    side = max(1 << k, pow2_min)
    while side <= pow2_max:
        icons_per_row = side // cell_stride
        total_capacity = icons_per_row * icons_per_row
        if total_capacity >= n_images:
            return side, icons_per_row
        side <<= 1
    raise RuntimeError(f"Cannot fit {n_images} icons up to max atlas side {pow2_max}")


def generate_cpp_header(mapping, atlas_size, icon_size, header_path, atlas_filename):
    """
    mapping: list of tuples (name, x, y) where x,y point to the top-left of the inner icon area (excluding padding)
    atlas_size: integer side length (square)
    icon_size: size of each inner square icon (not including padding)
    Writes a header with unordered_map<string, pair<ImVec2, ImVec2>> providing UV rects.
    """
    header_lines = []
    header_lines.append("// Generated by MakeAtlas.py")
    header_lines.append("#pragma once")
    header_lines.append("#include <unordered_map>")
    header_lines.append("#include <string>")
    header_lines.append("#include <utility>")
    header_lines.append("#include <imgui.h>")
    header_lines.append("")
    header_lines.append(f"// Atlas size: {atlas_size} x {atlas_size}")
    header_lines.append(f"// Icon size (inner): {icon_size} x {icon_size}")
    header_lines.append(f"// Per-icon padding: {PAD} px on each side")
    header_lines.append(f"// Atlas image file: \"{atlas_filename}\"")
    header_lines.append("// Icons were aspect-ratio preserved and letterboxed (no upscaling)")
    header_lines.append("")
    header_lines.append("static const std::unordered_map<std::string, std::pair<ImVec2, ImVec2>> ICON_ATLAS_UV = {")
    for name, x, y in sorted(mapping, key=lambda t: t[0]):
        tl_u = x / atlas_size
        tl_v = y / atlas_size
        br_u = (x + icon_size) / atlas_size
        br_v = (y + icon_size) / atlas_size
        header_lines.append(
            f'    {{ "{name}", std::make_pair(ImVec2({tl_u:.6f}f, {tl_v:.6f}f), ImVec2({br_u:.6f}f, {br_v:.6f}f)) }},')
    header_lines.append("};")
    header_lines.append("")
    header_lines.append(f"static const int ICON_ATLAS_SIZE = {atlas_size};")
    header_lines.append(f"static const int ICON_SIZE = {icon_size};")
    header_content = "\n".join(header_lines)
    header_path = Path(header_path)
    header_path.write_text(header_content, encoding="utf-8")
    print(f"Wrote C++ header: {header_path}")


def _prepare_icon_cells(images: List, names: List[str]) -> Tuple[List, int]:
    """Given original images (RGBA), compute target icon_size and produce square letterboxed cells.
    icon_size is chosen as the maximum of width/height across inputs so we preserve detail (no upscaling).
    Returns (processed_cells, icon_size) where each processed cell is icon_size x icon_size RGBA image.
    """
    if not images:
        raise ValueError("No images provided")
    # Determine target size: choose the maximum dimension among inputs to avoid upscaling (we only downscale larger images)
    icon_size = max(max(img.size) for img in images)
    print(f"Detected icon size (inner) : {icon_size}x{icon_size}")
    processed = []
    for img in images:
        w, h = img.size
        # Compute scale (downscale only)
        scale = min(icon_size / w, icon_size / h, 1.0)
        new_w = int(w * scale)
        new_h = int(h * scale)
        if scale < 1.0:
            resized = img.resize((new_w, new_h), PILImage.LANCZOS)
        else:
            resized = img  # no upscaling
        cell = PILImage.new("RGBA", (icon_size, icon_size), (0, 0, 0, 0))
        x_off = (icon_size - new_w) // 2
        y_off = (icon_size - new_h) // 2
        cell.paste(resized, (x_off, y_off), resized)
        processed.append(cell)
    return processed, icon_size


def main():
    ap = argparse.ArgumentParser(description="Build icon atlas from PNGs (any size/aspect)")
    ap.add_argument("--in", dest="in_dir", default=".", help="Input folder with .png files (default: current dir)")
    ap.add_argument("--out-atlas", dest="out_atlas", default="atlas.png", help="Output atlas PNG filename")
    ap.add_argument("--out-header", dest="out_header", default="icon_atlas_map.h", help="Output C++ header file")
    args = ap.parse_args()

    in_dir = Path(args.in_dir)
    if not in_dir.exists() or not in_dir.is_dir():
        print(f"Input folder not found: {in_dir}", file=sys.stderr)
        sys.exit(1)

    # Collect PNGs, ignoring any that match the output atlas filename (case-insensitive)
    out_atlas_name = Path(args.out_atlas).name.lower()
    png_paths = sorted([
        p for p in in_dir.iterdir()
        if p.suffix.lower() == ".png" and p.name.lower() != out_atlas_name
    ])
    if not png_paths:
        print("No .png files found in input folder (after exclusions).", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(png_paths)} PNG files. Loading...")

    original_images: List = []
    names: List[str] = []
    for png_path in png_paths:
        name = png_path.stem
        try:
            img = PILImage.open(png_path).convert("RGBA")
            original_images.append(img)
            names.append(name)
        except Exception as e:
            print(f"Failed to load {png_path}: {e}", file=sys.stderr)
            sys.exit(1)

    if not original_images:
        print("No valid PNG images loaded.", file=sys.stderr)
        sys.exit(1)

    # Produce standardized icon cells (inner icon area)
    icon_cells, icon_size = _prepare_icon_cells(original_images, names)

    # compute per-icon cell stride including padding on all sides
    cell_stride = icon_size + (2 * PAD)

    n = len(icon_cells)
    atlas_side, icons_per_row = find_min_power2_side(n, cell_stride)
    print(
        f"Selected atlas side: {atlas_side} (icons per row/col: {icons_per_row}) -> capacity {icons_per_row * icons_per_row}")

    atlas = PILImage.new("RGBA", (atlas_side, atlas_side), (0, 0, 0, 0))
    mapping = []  # (name, x, y) where x,y point to the inner icon top-left (exclude padding)
    for i, (name, cell) in enumerate(zip(names, icon_cells)):
        col = i % icons_per_row
        row = i // icons_per_row
        # compute top-left of the inner icon area (offset by padding inside each cell)
        x = col * cell_stride + PAD
        y = row * cell_stride + PAD
        atlas.paste(cell, (x, y), cell)
        mapping.append((name, x, y))

    atlas.save(args.out_atlas)
    print(f"Wrote atlas PNG: {args.out_atlas}")

    generate_cpp_header(mapping, atlas_side, icon_size, args.out_header, os.path.basename(args.out_atlas))
    print(f"\nSuccessfully packed {n} icons into {atlas_side}x{atlas_side} atlas")


if __name__ == "__main__":
    main()
