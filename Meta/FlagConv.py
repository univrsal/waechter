#!/usr/bin/env python3
"""
make_flag_atlas.py

Converts SVG flags to 64x48 PNGs, packs them into the smallest square power-of-two atlas,
and writes a C++ header mapping filename -> (x, y) top-left coordinates.

Usage:
    python make_flag_atlas.py --in ./flags --out-atlas atlas.png --out-header flag_atlas_map.h
"""

import sys
import os
import argparse
from math import ceil
from io import BytesIO
from pathlib import Path

from PIL import Image
import cairosvg

# --- Configurable defaults ---
TARGET_W = 32
TARGET_H = 24
POWER2_MIN = 64   # minimal atlas side to consider
POWER2_MAX = 16384  # safety cap (should be plenty)
# -----------------------------

def render_svg_to_png_bytes(svg_path, width=None, height=None):
    # Use cairosvg to render to PNG bytes
    # Provide explicit output_width/output_height to cairosvg so it scales cleanly.
    out = BytesIO()
    cairosvg.svg2png(url=str(svg_path), write_to=out, output_width=width, output_height=height)
    out.seek(0)
    return out.read()

def find_min_power2_side(n_images, w, h, pow2_min=POWER2_MIN, pow2_max=POWER2_MAX):
    # Find smallest square power-of-two side such that floor(side/w) * floor(side/h) >= n_images
    side = pow2_min
    # Ensure starting side is at least max(w,h)
    side = max(side, 1 << (max(w, h)-1).bit_length())
    # but simpler: start with 2**k where 2**k >= max(w,h)
    k = (max(w, h)-1).bit_length()
    side = 1 << k
    while side <= pow2_max:
        cols = side // w
        rows = side // h
        if cols * rows >= n_images:
            return side, cols, rows
        side <<= 1
    raise RuntimeError(f"Cannot fit {n_images} images up to max atlas side {pow2_max}")

def generate_cpp_header(mapping, atlas_size, header_path, atlas_filename):
    """
    mapping: list of tuples (name, x, y)
    atlas_size: integer side length (square)
    Writes a simple header with unordered_map<string, pair<int,int>>
    """
    header_lines = []
    header_lines.append("// Generated by make_flag_atlas.py")
    header_lines.append("#pragma once")
    header_lines.append("#include <unordered_map>")
    header_lines.append("#include <string>")
    header_lines.append("#include <utility>")
    header_lines.append("")
    header_lines.append(f"// Atlas size: {atlas_size} x {atlas_size}")
    header_lines.append(f"// Atlas image file: \"{atlas_filename}\"")
    header_lines.append("")
    header_lines.append("static const std::unordered_map<std::string, std::pair<int,int>> FLAG_ATLAS_POS = {")
    # Keep entries sorted for deterministic output
    for name, x, y in sorted(mapping, key=lambda t: t[0]):
        header_lines.append(f'    {{ "{name}", std::make_pair({x}, {y}) }},')
    header_lines.append("};")
    header_content = "\n".join(header_lines)
    header_path = Path(header_path)
    header_path.write_text(header_content, encoding="utf-8")
    print(f"Wrote C++ header: {header_path}")

def main():
    ap = argparse.ArgumentParser(description="Build flag atlas from SVGs")
    ap.add_argument("--in", dest="in_dir", default="./flags", help="Input folder with .svg files")
    ap.add_argument("--out-atlas", dest="out_atlas", default="atlas.png", help="Output atlas PNG filename")
    ap.add_argument("--out-header", dest="out_header", default="flag_atlas_map.h", help="Output C++ header file")
    ap.add_argument("--save-pngs", dest="save_pngs", action="store_true", help="Also save individual PNGs to out_pngs/")
    ap.add_argument("--w", dest="w", type=int, default=TARGET_W, help="Target width for each flag (default 64)")
    ap.add_argument("--h", dest="h", type=int, default=TARGET_H, help="Target height for each flag (default 48)")
    args = ap.parse_args()

    in_dir = Path(args.in_dir)
    if not in_dir.exists() or not in_dir.is_dir():
        print(f"Input folder not found: {in_dir}", file=sys.stderr)
        sys.exit(1)

    svg_paths = sorted([p for p in in_dir.iterdir() if p.suffix.lower() == ".svg"])
    if not svg_paths:
        print("No .svg files found in input folder.", file=sys.stderr)
        sys.exit(1)

    target_w = args.w
    target_h = args.h

    print(f"Found {len(svg_paths)} SVG files. Rendering to {target_w}x{target_h} each...")

    # Render & resize each svg to a PIL image
    images = []
    names = []
    for svgp in svg_paths:
        name = svgp.stem  # filename without extension
        try:
            png_bytes = render_svg_to_png_bytes(svgp, width=target_w, height=target_h)
            img = Image.open(BytesIO(png_bytes)).convert("RGBA")
            # Some renderers might produce slightly different sizes; enforce exact size:
            if img.size != (target_w, target_h):
                img = img.resize((target_w, target_h), Image.LANCZOS)
            images.append(img)
            names.append(name)
        except Exception as e:
            print(f"Failed to render {svgp}: {e}", file=sys.stderr)
            sys.exit(1)

    n = len(images)
    atlas_side, cols, rows = find_min_power2_side(n, target_w, target_h)
    print(f"Selected atlas side: {atlas_side} (cols={cols}, rows={rows}) -> capacity {cols*rows}")

    # Create atlas image
    atlas = Image.new("RGBA", (atlas_side, atlas_side), (0,0,0,0))

    mapping = []  # tuples (name, x, y)
    for i, (name, img) in enumerate(zip(names, images)):
        col = i % cols
        row = i // cols
        if row >= rows:
            raise RuntimeError("Not enough rows â€” packing logic error")
        x = col * target_w
        y = row * target_h
        atlas.paste(img, (x, y), img)
        mapping.append((name, x, y))

    # Save atlas
    atlas.save(args.out_atlas)
    print(f"Wrote atlas PNG: {args.out_atlas}")

    # Optionally save individual PNGs
    if args.save_pngs:
        out_pngs_dir = Path("out_pngs")
        out_pngs_dir.mkdir(exist_ok=True)
        for name, img in zip(names, images):
            p = out_pngs_dir / f"{name}.png"
            img.save(p)
        print(f"Wrote individual PNGs to {out_pngs_dir}")

    # Write C++ header
    generate_cpp_header(mapping, atlas_side, args.out_header, os.path.basename(args.out_atlas))

if __name__ == "__main__":
    main()

