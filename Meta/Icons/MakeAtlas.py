#!/usr/bin/env python3
"""
MakeAtlas.py

Packs square PNG icons into a power-of-two atlas and generates a C++ header
mapping icon name -> (x, y) top-left coordinates.

Updated:
 - Ignores any input file named like the output atlas (e.g. atlas.png) to prevent self-inclusion.
 - Accepts arbitrary size/aspect PNGs. Determines a target icon size automatically (minimum of min(width,height) across inputs) and downsizes larger images while preserving aspect ratio. Images are letterboxed (centered) on a square transparent canvas of icon_size x icon_size without upscaling smaller ones.

Usage:
    python MakeAtlas.py [--in ./icons] [--out-atlas atlas.png] [--out-header icon_atlas_map.h]
"""

import argparse
import os
import sys
from pathlib import Path
from typing import List, Tuple

try:
    from PIL import Image
except ImportError:
    print("Error: Pillow (PIL) library not found. Install with: pip install Pillow", file=sys.stderr)
    sys.exit(1)

POWER2_MIN = 64  # minimal atlas side to consider
POWER2_MAX = 16384  # safety cap


def find_min_power2_side(n_images, icon_size, pow2_min=POWER2_MIN, pow2_max=POWER2_MAX):
    """Find smallest square power-of-two side such that
    floor(side/icon_size) * floor(side/icon_size) >= n_images"""
    k = (icon_size - 1).bit_length()
    side = max(1 << k, pow2_min)
    while side <= pow2_max:
        icons_per_row = side // icon_size
        total_capacity = icons_per_row * icons_per_row
        if total_capacity >= n_images:
            return side, icons_per_row
        side <<= 1
    raise RuntimeError(f"Cannot fit {n_images} icons up to max atlas side {pow2_max}")


def generate_cpp_header(mapping, atlas_size, icon_size, header_path, atlas_filename):
    """
    mapping: list of tuples (name, x, y)
    atlas_size: integer side length (square)
    icon_size: size of each square icon
    Writes a header with unordered_map<string, pair<int,int>>
    """
    header_lines = []
    header_lines.append("// Generated by MakeAtlas.py")
    header_lines.append("#pragma once")
    header_lines.append("#include <unordered_map>")
    header_lines.append("#include <string>")
    header_lines.append("#include <utility>")
    header_lines.append("")
    header_lines.append(f"// Atlas size: {atlas_size} x {atlas_size}")
    header_lines.append(f"// Icon size: {icon_size} x {icon_size}")
    header_lines.append(f"// Atlas image file: \"{atlas_filename}\"")
    header_lines.append("// Icons were aspect-ratio preserved and letterboxed (no upscaling)")
    header_lines.append("")
    header_lines.append("static const std::unordered_map<std::string, std::pair<int,int>> ICON_ATLAS_POS = {")
    for name, x, y in sorted(mapping, key=lambda t: t[0]):
        header_lines.append(f'    {{ "{name}", std::make_pair({x}, {y}) }},')
    header_lines.append("};")
    header_lines.append("")
    header_lines.append(f"static const int ICON_ATLAS_SIZE = {atlas_size};")
    header_lines.append(f"static const int ICON_SIZE = {icon_size};")
    header_content = "\n".join(header_lines)
    header_path = Path(header_path)
    header_path.write_text(header_content, encoding="utf-8")
    print(f"Wrote C++ header: {header_path}")


def _prepare_icon_cells(images: List[Image.Image], names: List[str]) -> Tuple[List[Image.Image], int]:
    """Given original images (RGBA), compute target icon_size and produce square letterboxed cells.
    icon_size is chosen as the minimum of each image's min(width, height) ensuring only downscaling.
    Returns (processed_cells, icon_size)."""
    if not images:
        raise ValueError("No images provided")
    # Determine target size: smallest min dimension among all images
    icon_size = max(max(img.size) for img in images)
    print(f"Detected icon size (cell size): {icon_size}x{icon_size}")
    processed = []
    for img in images:
        w, h = img.size
        # Compute scale (downscale only)
        scale = min(icon_size / w, icon_size / h, 1.0)
        new_w = int(w * scale)
        new_h = int(h * scale)
        if scale < 1.0:
            resized = img.resize((new_w, new_h), Image.LANCZOS)
        else:
            resized = img  # no upscaling
        cell = Image.new("RGBA", (icon_size, icon_size), (0, 0, 0, 0))
        x_off = (icon_size - new_w) // 2
        y_off = (icon_size - new_h) // 2
        cell.paste(resized, (x_off, y_off), resized)
        processed.append(cell)
    return processed, icon_size


def main():
    ap = argparse.ArgumentParser(description="Build icon atlas from PNGs (any size/aspect)")
    ap.add_argument("--in", dest="in_dir", default=".", help="Input folder with .png files (default: current dir)")
    ap.add_argument("--out-atlas", dest="out_atlas", default="atlas.png", help="Output atlas PNG filename")
    ap.add_argument("--out-header", dest="out_header", default="icon_atlas_map.h", help="Output C++ header file")
    args = ap.parse_args()

    in_dir = Path(args.in_dir)
    if not in_dir.exists() or not in_dir.is_dir():
        print(f"Input folder not found: {in_dir}", file=sys.stderr)
        sys.exit(1)

    # Collect PNGs, ignoring any that match the output atlas filename (case-insensitive)
    out_atlas_name = Path(args.out_atlas).name.lower()
    png_paths = sorted([
        p for p in in_dir.iterdir()
        if p.suffix.lower() == ".png" and p.name.lower() != out_atlas_name
    ])
    if not png_paths:
        print("No .png files found in input folder (after exclusions).", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(png_paths)} PNG files. Loading...")

    original_images: List[Image.Image] = []
    names: List[str] = []
    for png_path in png_paths:
        name = png_path.stem
        try:
            img = Image.open(png_path).convert("RGBA")
            original_images.append(img)
            names.append(name)
        except Exception as e:
            print(f"Failed to load {png_path}: {e}", file=sys.stderr)
            sys.exit(1)

    if not original_images:
        print("No valid PNG images loaded.", file=sys.stderr)
        sys.exit(1)

    # Produce standardized icon cells
    icon_cells, icon_size = _prepare_icon_cells(original_images, names)

    n = len(icon_cells)
    atlas_side, icons_per_row = find_min_power2_side(n, icon_size)
    print(
        f"Selected atlas side: {atlas_side} (icons per row/col: {icons_per_row}) -> capacity {icons_per_row * icons_per_row}")

    atlas = Image.new("RGBA", (atlas_side, atlas_side), (0, 0, 0, 0))
    mapping = []  # (name, x, y)
    for i, (name, cell) in enumerate(zip(names, icon_cells)):
        col = i % icons_per_row
        row = i // icons_per_row
        x = col * icon_size
        y = row * icon_size
        atlas.paste(cell, (x, y), cell)
        mapping.append((name, x, y))

    atlas.save(args.out_atlas)
    print(f"Wrote atlas PNG: {args.out_atlas}")

    generate_cpp_header(mapping, atlas_side, icon_size, args.out_header, os.path.basename(args.out_atlas))
    print(f"\nSuccessfully packed {n} icons into {atlas_side}x{atlas_side} atlas")


if __name__ == "__main__":
    main()
